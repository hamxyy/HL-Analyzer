/*
 * generated by Xtext
 */
package de.itemis.xtext.typesystem.dsl.generator
   
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import de.itemis.xtext.typesystem.dsl.tsDsl.TypesystemSpec
import de.itemis.xtext.typesystem.dsl.tsDsl.CloneRule
import de.itemis.xtext.typesystem.dsl.tsDsl.MetaclassSpec
import de.itemis.xtext.typesystem.dsl.tsDsl.FixedTypingRule
import de.itemis.xtext.typesystem.dsl.tsDsl.TypingRule
import de.itemis.xtext.typesystem.dsl.tsDsl.TypeOfFeatureRule
import de.itemis.xtext.typesystem.dsl.tsDsl.CommonSuperTypeOfRule
import de.itemis.xtext.typesystem.dsl.tsDsl.AbstractTypeTypingRule
import de.itemis.xtext.typesystem.dsl.tsDsl.TypeConstraint
import de.itemis.xtext.typesystem.dsl.tsDsl.FeatureTypeConstraint
import de.itemis.xtext.typesystem.dsl.tsDsl.EClassRef
import de.itemis.xtext.typesystem.dsl.tsDsl.CharRef
import de.itemis.xtext.typesystem.dsl.tsDsl.ComatibilityTypeConstraint
import de.itemis.xtext.typesystem.dsl.tsDsl.SameTypeOp
import de.itemis.xtext.typesystem.dsl.tsDsl.SubTypeOp
import de.itemis.xtext.typesystem.dsl.tsDsl.UnoderedSubtypeOp
import de.itemis.xtext.typesystem.dsl.tsDsl.JavaCodeTypingRule
import de.itemis.xtext.typesystem.dsl.tsDsl.TypeOfAncestor

import com.google.inject.Inject
import org.eclipse.emf.ecore.EClass


class TsDslGenerator implements IGenerator {

	@Inject extension Utils utils

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val m = resource.contents.get(0) as TypesystemSpec
		fsa.generateFile( m.name.replaceAll("\\.", "/")+"Generated.java",
		'''
		package «m.pack»;

		import org.eclipse.emf.ecore.EObject;
		import de.itemis.xtext.typesystem.exceptions.TypesystemConfigurationException;
		import de.itemis.xtext.typesystem.trace.TypeCalculationTrace;
		import de.itemis.xtext.typesystem.characteristics.TypeCharacteristic;

		public «IF m.all.exists(s|typeof(JavaCodeTypingRule).isInstance( s.typingRule ))» abstract «ENDIF»class «m.className» extends de.itemis.xtext.typesystem.DefaultTypesystem {

			protected «m.languagePack» p = «m.languagePack».eINSTANCE;

			«FOR s: m.sections»
				«FOR c: s.characteristics» 
					private TypeCharacteristic «c.name» = new TypeCharacteristic("«c.name»");
				«ENDFOR»
			«ENDFOR»

			protected void initialize() {

				try {

					«FOR s: m.sections»
						// ----------------------------------------------------------------
						// Section: «s.name»


						«FOR c: s.characteristics» 
							«FOR t: c.types»
								declareCharacteristic(«t.getter», «c.name»);
							«ENDFOR»
						«ENDFOR»

						«FOR sts: s.subtypeSpec»
							declareSubtype( «sts.subtype.getter», «sts.supertype.getter»);
						«ENDFOR»
						«FOR MetaclassSpec ms: s.metaclassSpecs»
							«IF ms.includeSubtypes»
								// include subtypes! 
								«ms.typingRule.rulecode(ms.clazz)»
								«FOR sub: ms.clazz.subtypes»
									«IF !ms.ts.hasDirectSpecFor(sub)»
										«ms.typingRule.rulecode(sub)»
									«ENDIF»
									«FOR con: ms.constraints»
										«con.constraintcode(sub)»
									«ENDFOR»
								«ENDFOR»
								// ------
							«ELSE»
								«ms.typingRule.rulecode(ms.clazz)»
								«FOR con: ms.constraints»
									«con.constraintcode(ms.clazz)»
								«ENDFOR»
							«ENDIF»
							«FOR tcf: ms.comparisonFeatures»
								declareTypeComparisonFeature( «ms.clazz.getter», «tcf.feature.getter» );
							«ENDFOR»
							«FOR tcf: ms.recursionFeatures»
								declareTypeRecursionFeature( «ms.clazz.getter», «tcf.feature.getter» );
							«ENDFOR»
						«ENDFOR»

					«ENDFOR»
				} catch ( TypesystemConfigurationException ex ) {
					ex.printStackTrace();
				}
			}

			«FOR s: m.sections /*could be nicer! */»
				«FOR MetaclassSpec ms: s.metaclassSpecs»
					«IF typeof(JavaCodeTypingRule).isInstance(ms.typingRule)»
						protected abstract EObject type( «m.languagePack.skipLastSegment».«ms.clazz.name» element, TypeCalculationTrace trace );
					«ENDIF»
				«ENDFOR»
			«ENDFOR»

		}
		''' )
	}

	def dispatch rulecode( TypingRule tr, EClass clazz ) ''''''
	def dispatch rulecode( CloneRule cr, EClass clazz ) '''useCloneAsType( «clazz.getter» );'''
	def dispatch rulecode( FixedTypingRule ft, EClass clazz ) '''useFixedType( «clazz.getter», «ft.clazz.getter» );'''
	def dispatch rulecode( TypeOfFeatureRule cfr, EClass clazz ) '''useTypeOfFeature( «clazz.getter», «cfr.feature.getter» );'''
	def dispatch rulecode( CommonSuperTypeOfRule str, EClass clazz ) '''computeCommonType( «clazz.getter», «str.feature1.getter», «str.feature2.getter»);'''
	def dispatch rulecode( TypeOfAncestor atr, EClass clazz ) '''useTypeOfAncestor( «clazz.getter», «atr.clazz.getter» );'''




	def dispatch constraintcode( FeatureTypeConstraint tc, EClass clazz ) '''
		ensureFeatureType( «IF tc.errorMsg != null»"«tc.errorMsg»", «ENDIF»«clazz.getter», «tc.feature.getter»«tc.types.fold("",[s, e|s+", "+e.code])» );
	'''

	def dispatch constraintcode( ComatibilityTypeConstraint tc, EClass clazz ) {
		switch (tc.op) {
			SameTypeOp: "TODO currently not yet suported"
			SubTypeOp: '''ensureOrderedCompatibility( «IF tc.errorMsg != null»"«tc.errorMsg»", «ENDIF»«clazz.getter», «tc.feature1.getter», «tc.feature2.getter» );'''
			UnoderedSubtypeOp: '''ensureUnorderedCompatibility( «IF tc.errorMsg != null»"«tc.errorMsg»", «ENDIF»«clazz.getter», «tc.feature1.getter», «tc.feature2.getter» );'''
		} 
	} 

	def dispatch code( EClassRef ref) {
		ref.clazz.getter
	}

	def dispatch code( CharRef ref) {
		ref.char.name
	}

}
