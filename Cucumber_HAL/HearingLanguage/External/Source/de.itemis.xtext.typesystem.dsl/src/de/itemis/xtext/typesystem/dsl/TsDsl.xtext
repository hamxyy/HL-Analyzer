grammar de.itemis.xtext.typesystem.dsl.TsDsl with org.eclipse.xtext.common.Terminals

generate tsDsl "http://www.itemis.de/xtext/typesystem/dsl/TsDsl"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

TypesystemSpec:
	"typesystem" name=QualID 
		"ecore" "file" ecoreUri=STRING
		"language package" languagePack=QualID
	(sections+=Section)*;


Section:
	"section" name=STRING
		(metaclassSpecs+=MetaclassSpec | 
		 characteristics+=CharDef |
		 subtypeSpec+=SubtypeSpec	
		)*;

SubtypeSpec:
	"subtype" subtype=[ecore::EClass] "base" supertype=[ecore::EClass];


CharDef:
	"characteristic" name=ID "{" 
		types+=[ecore::EClass] ("," types+=[ecore::EClass])*
	"}";



MetaclassSpec:
	"typeof" clazz=[ecore::EClass] (includeSubtypes?="+")? "->" typingRule=TypingRule
		("{" (constraints+=TypeConstraint |
			 comparisonFeatures+=TypeComparisonFeature |
			 recursionFeatures+=TypeRecursionFeatures )* "}")?;

TypeRecursionFeatures:
	"recurse" feature=[ecore::EStructuralFeature];



TypeComparisonFeature:
	"compare" feature=[ecore::EStructuralFeature];


TypeConstraint:
	FeatureTypeConstraint | ComatibilityTypeConstraint;

ComatibilityTypeConstraint:
	"ensureCompatibility" feature1=[ecore::EStructuralFeature] op=Op feature2=[ecore::EStructuralFeature] (errorMsg=STRING)?;
	
FeatureTypeConstraint:
	"ensureType" feature=[ecore::EStructuralFeature] op=SubTypeOp (types+=TypeSpec) ("," types+=TypeSpec)* (errorMsg=STRING)?;

TypeSpec:
		EClassRef | CharRef;

CharRef:
	"char" "(" char=[CharDef] ")";


EClassRef:
	clazz=[ecore::EClass];


Op:
	SameTypeOp | SubTypeOp | UnoderedSubtypeOp;

UnoderedSubtypeOp:
	{UnoderedSubtypeOp} ":<=>:";

SubTypeOp:
	{SubTypeOp} ":<=:";

SameTypeOp:
	{SameTypeOp} ":==:";

	
	



TypingRule:
	CloneRule | TypeOfFeatureRule | FixedTypingRule | CommonSuperTypeOfRule | 
	JavaCodeTypingRule | TypeOfAncestor | AbstractTypeTypingRule | NoTypeRule | TbdRule;

TbdRule:
	{TbdRule} "tbd";

NoTypeRule:
	{NoTypeRulw} "none";


JavaCodeTypingRule:
	{JavaCodeTypingRule} "javacode";


TypeOfAncestor: // TODO make sure that we check that the clazz is an ancestor, and that we have a typing rule for that
	{TypeOfAncestor} "ancestor" clazz=[ecore::EClass];


AbstractTypeTypingRule:
	{AbstractTypeTypingRule} "abstract";


CommonSuperTypeOfRule:
	"common" feature1=[ecore::EStructuralFeature] feature2=[ecore::EStructuralFeature];

FixedTypingRule:
	clazz=[ecore::EClass];


TypeOfFeatureRule:
	"feature" feature=[ecore::EStructuralFeature];


CloneRule:
	{CloneRule} "clone";


	
QualID:
	ID ("."ID)*;