/*
 * generated by Xtext
 */
package com.shs.hl.generator

import com.google.inject.Inject

import com.shs.common.commonLanguage.EnumLiteral
import com.shs.hl.generator.utils.GenCode
import com.shs.hl.generator.utils.GenUtils
import com.shs.hl.generator.utils.HLCSharpBeautifier
import com.shs.hl.generator.utils.TestCaseGen
import com.shs.hl.hearingLanguage.FunctionDeclaration
import com.shs.hl.hearingLanguage.FunctionKind
import com.shs.hl.hearingLanguage.Module
import com.shs.hl.hearingLanguage.Namespace
import com.shs.hl.hearingLanguage.PackageKind
import com.shs.hl.hearingLanguage.ParameterDeclaration
import com.shs.hl.hearingLanguage.ParameterReadExpression
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess

//import org.eclipse.xtext.generator.IGenerator
import com.shs.hl.generator.GenerationInfo.PlatformInformation

//import com.shs.hl.util.LineGene
class HearingLanguageGenerator2 implements IHLGenerator {

	@Inject extension GenUtils genUtil;
	@Inject extension GenCode gen;

	//var HearingLanguageBeautifier beauti = new HearingLanguageBeautifier();
	val HLCSharpBeautifier beauti = new HLCSharpBeautifier();

	var PlatformInfo = PlatformInformation.D8;

	override SetPlatformVersion(PlatformInformation info) {
		PlatformInfo = info;
	}

	override doGenerate(PlatformInformation info, Resource input, IFileSystemAccess fsa) {
		PlatformInfo = info;
		doGenerate(input, fsa);
	}

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for (namesp : resource.allContents.toIterable.filter(typeof(Namespace)))
			if (isModule(namesp.eContainer()) && !namesp.name.equals("builtins")) {
				fsa.generateFile((GenUtils::resFileName(namesp.eContainer() as Module)),
					beauti.format(
						'''
							«(namesp.eContainer() as Module).doGenerateModule»  	 
						'''
					))
			}
	}

	def getRootNamespace() {
		"SHS.SAT.FittingHIDBInterfaces.HearingLanguageRuntime"
	}

	def String getFile(Module mode) {
		''
	}

	def CharSequence getCsharpHeader() '''
		namespace «rootNamespace»
			 { 
			 	// Hello, I'm a good hacker.
			 using System;
			 using System.Diagnostics;
			 using System.Collections.Generic;
			 using Identifiers;
			 «getPlatformHeader()»
		
		 
	'''

	def getPlatformHeader() {
		switch (PlatformInfo) {
			case PlatformInformation.D9: '''using HIPlatformData.D9.HearingAidLanguage;'''
			default: '''using HIPlatformData.D8.HearingAidLanguage;'''
		}
	}

	def String getNameSpaceHeader(Namespace space) {
		''
	}

	def String name(EObject obj) {
		obj.name;
	}

	def boolean isModule(EObject ob) {
		return (ob instanceof Module)
	}

	//		//for debuging, remove , targeted generation of specific HL file
	//	def boolean canGenerate(Module m){
	//	 EcoreUtil2::getAllContentsOfType(m,typeof(Namespace)).map(b | b.name.equals("BasicLibrary_MicrophoneMix") ).contains(true)
	//	 }
	def generate(EObject ob) {
		switch (ob) {
			Module: doGenerateModule(ob)
			Namespace: doGenerateNamespace(ob)
			default: '''//Error no toplevel element'''
		}
	}

	def doGenerateModule(Module m) {
		'''
			«csharpHeader»
			«FOR c : m.namespaces»
				«c.doGenerateNamespace»
			«ENDFOR»
			}
		'''
	}

	def CharSequence doGenerateNamespace(Namespace n) '''
		«IF n.isPackage»
			«IF GenUtils::hasTestFunctions(n)»
				using SHS.SAT.HAL.Testing;
			«ENDIF»
			
			public class «n.name» «n.extendsClause()»
			{
			«IF GenUtils::hasTestFunctions(n)»
				«TestCaseGen::genTest(n)» 
			«ENDIF»
			«IF (n.requiresFunctionDependency)»
				«FOR m : n.functions.filter(typeof(FunctionDeclaration))»
					«m.functionDefinitionDependency»
				«ENDFOR»
			«ENDIF»
			
			«FOR m : n.functions.filter(typeof(FunctionDeclaration))»
				«m.functionDefinition»
			«ENDFOR»
			}
		«ELSE»
			namespace «n.csNamespace» { «FOR kind : n.namespaces»
					 «doGenerateNamespace(kind)»
			«ENDFOR»
			}
		«ENDIF»
	'''

	def CharSequence functionDefinition(FunctionDeclaration decl) '''
		«IF (decl.kind == FunctionKind::TEST )»[TestMethod] «GenUtils::registerTestFunction(decl,
			(decl.eContainer as Namespace).csNamespace, (decl.eContainer as Namespace).csNamespace)» «ENDIF»
		«IF (decl.kind == FunctionKind::APPLICATION)»/*application*/ «ENDIF»
		 public «IF (decl.kind == FunctionKind::APPLICATION)»override«ENDIF» «decl.type.asCsType» «decl.name»(«val params = decl.
			args.filter(typeof(ParameterDeclaration))» «FOR arg : params» «arg.type.asCsType» «arg.name»«IF params.last != arg»,«ENDIF» «ENDFOR» )
		 «decl.body.genCode»
	'''

	def functionDefinitionDependency(FunctionDeclaration decl) '''
		«IF (decl.kind == FunctionKind::APPLICATION)»
			public override IEnumerable<object> Get«decl.name»Dependencies() 
			{
			       	«FOR paraEx : GenUtils::getParameterReadExpressions(decl)»
			       		«paraEx.parameterReadExpressionDependency»
			       	«ENDFOR»
			       	«FOR enuLit : GenUtils::getEnumLiterals(decl)»
			       		«enuLit.enumLitealDependency» 
			       	«ENDFOR»
			yield break;
			}
			«ENDIF»		
	'''

	def parameterReadExpressionDependency(ParameterReadExpression readExpr) '''
		«IF (readExpr.scope.toString.equals("hi"))»
			yield return «readExpr.scope.controlsClass».«readExpr.param.name»;
		«ENDIF»
	'''

	def enumLitealDependency(EnumLiteral literal) '''	yield return «literal.genCode»;'''

	def boolean requiresFunctionDependency(Namespace ns) {
		switch (ns.packKind) {
			case PackageKind::MIXED_MODE: true
			case PackageKind::FITTING_ASSISTENT: true
			default: false
		}
	}

}
