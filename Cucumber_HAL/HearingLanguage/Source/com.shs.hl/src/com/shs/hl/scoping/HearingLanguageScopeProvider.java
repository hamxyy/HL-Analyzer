/*
 * generated by Xtext
 */
package com.shs.hl.scoping;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.FilteringScope;
import org.eclipse.xtext.scoping.impl.ImportNormalizer;
import org.eclipse.xtext.scoping.impl.MapBasedScope;

import com.google.common.base.Predicate;
import com.google.common.collect.Collections2;
import com.google.inject.Inject;
import com.shs.common.commonLanguage.CommonLanguagePackage;
import com.shs.common.commonLanguage.SymbolDeclaration;
import com.shs.common.od.CommonResourceDescriptionStrategy;
import com.shs.hl.hearingLanguage.AssignmentStatement;
import com.shs.hl.hearingLanguage.BuiltInCall;
import com.shs.hl.hearingLanguage.BuiltInMethodCall;
import com.shs.hl.hearingLanguage.BuiltInOp;
import com.shs.hl.hearingLanguage.Expression;
import com.shs.hl.hearingLanguage.ForeachStatement;
import com.shs.hl.hearingLanguage.FunctionDeclaration;
import com.shs.hl.hearingLanguage.HearingLanguagePackage;
import com.shs.hl.hearingLanguage.LocalVariableDeclaration;
import com.shs.hl.hearingLanguage.LocalVariableDeclarationStatement;
import com.shs.hl.hearingLanguage.Namespace;
import com.shs.hl.hearingLanguage.ParameterReadExpression;
import com.shs.hl.hearingLanguage.Statement;
import com.shs.hl.hearingLanguage.StatementList;

import de.itemis.xtext.typesystem.ITypesystem;
import de.itemis.xtext.typesystem.trace.TypeCalculationTrace;
import de.itemis.xtext.typesystem.util.Utils;

/**
 * This class contains custom scoping description. You see :
 * http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on how
 * and when to use it
 * 
 */
public class HearingLanguageScopeProvider extends 
		AbstractDeclarativeScopeProvider {

	/**
	 * helper variable to turn on/off logging of scope methods for debugging
	 */
	private final boolean				logScopes	= false;

	/**
	 * the two language packages
	 */
	private final CommonLanguagePackage	 cl			= CommonLanguagePackage.eINSTANCE;
	private final HearingLanguagePackage hl			= HearingLanguagePackage.eINSTANCE;

	@Inject
	private ITypesystem					ts;

	/**
	 * when we look for a symbol in a statement, returns all the default C stuff
	 */
	public IScope scope_SymbolDeclaration(final Statement ctx, final EReference ref) {
		return defaultCStuff(ctx, delegateGetScope(ctx, ref));
	}

	/**
	 * find all the suitable built-Ins
	 */
	public IScope scope_BuiltInOp(final BuiltInCall ctx, final EReference ref) {
		
		
		
//		List<EObject> namesp = Utils.ancestors(ctx, hl.getNamespace());
//		Namespace foundOne=null;
//		if (namesp!=null)
//		{
//			for (EObject ob :namesp)
//			{
//				if(ob instanceof Namespace)
//				{
//					if(((Namespace) ob).getName().equalsIgnoreCase("builtins"))
//					{
//						foundOne = (Namespace) ob;
//					}
//				}
//			}
//		}
//		if (foundOne!=null)
//		{
//			
//		}
		
		Namespace ns = Utils.ancestor(ctx, Namespace.class);
		while (ns.getLib() == null) {
			ns = (Namespace) ns.eContainer();
			if (ns == null) return IScope.NULLSCOPE;
		}

		final EObject callContextType = ts.typeof(ctx.getExpr(), new TypeCalculationTrace());
		if (callContextType == null) return IScope.NULLSCOPE;
		final String callContextTypeName = callContextType.eClass().getName();
		
		
		final Namespace lib = ns.getLib();
		final List<BuiltInOp> res = new ArrayList<BuiltInOp>();
		for (final BuiltInOp builtInOp : lib.getBuiltIns()) {
			final String bit = ts.typeof(builtInOp.getContextType(), new TypeCalculationTrace()).eClass().getName();
			if (callContextTypeName.equals(bit)) {
				res.add(builtInOp);
			}
		}
		return Scopes.scopeFor(res);
	}

	
	public IScope scope_BuiltInMethodCall(final BuiltInMethodCall ctx, final EReference ref)
	{
		// get all BuiltInMethods
		// filter them according the context type
		// if so add it
		
		return IScope.NULLSCOPE;
		
	}
	
	
	
	
	/**
	 * from within an assignment statement, we also need the enum literals
	 */
	public IScope scope_SymbolDeclaration(final AssignmentStatement ctx, final EReference ref) {
		if (logScopes) System.err.println("scope_SymbolDeclaration( AssignmentStatement ctx, EReference ref )");
		return defaultCStuff(ctx, delegateGetScope(ctx, ref));
	}

	/**
	 * from within an expression we also need the imported parameters
	 */
	public IScope scope_SymbolDeclaration(final Expression ctx, final EReference ref) {
		if (logScopes) System.err.println("scope_SymbolDeclaration( Expression ctx, EReference ref )");
		final IScope scope = defaultCStuff(ctx, delegateGetScope(ctx, ref));
		return new FilteringScope(scope, new FilterForEClassPredicate(paramStuff()));
	}

	/**
	 * when we're in a ParameterReadExpression, we want all the parameters, but
	 * only those whose scope (hi, pat, ...) is the same as the one on the
	 * current ParameterReadExpression
	 */
	public IScope scope_SymbolDeclaration(final ParameterReadExpression ctx, final EReference ref) {
		if (logScopes) System.err.println("scope_SymbolDeclaration( final ParameterReadExpression ctx, EReference ref )");
		final IScope scope = new FilteringScope(delegateGetScope(ctx, ref), new FilterForEClassPredicate(paramStuff()));
		return new FilteringScope(scope, new ScopeFilterPredicate(ctx.getScope().getLiteral()));
	}

	static class FilterForEClassPredicate implements Predicate<IEObjectDescription>
	{

		private final EClass[]	allowedTypes;

		public FilterForEClassPredicate(final EClass... allowedTypes) {
			this.allowedTypes = allowedTypes;
		}

		@Override
		public boolean apply(final IEObjectDescription input) {
			for (final EClass eClass : allowedTypes) {
				if (eClass.isSuperTypeOf(eClass)) return true;
			}
			return false;
		}
	}

	/**
	 * In a LocalVariableDeclaration, when looking for symbols, we'll get the
	 * default C stuff and the parameters
	 */
	public IScope scope_SymbolDeclaration(final LocalVariableDeclaration ctx, final EReference ref)
	{
		if (logScopes) System.err.println("scope_SymbolDeclaration( LocalVariableDeclaration ctx, EReference ref )");
		final IScope scope = defaultCStuff(ctx, delegateGetScope(ctx, ref));
		// return new FilteringScope(scope, paramStuff());
		return new FilteringScope(scope, new FilterForEClassPredicate(paramStuff()));
	}

	/**
	 * helper function that returns a EClass array with the enum, integer and
	 * crv parameters; it is used above for enumerating the kinds of things that
	 * the scope should contain
	 */
	private EClass[] paramStuff()
	{
		return new EClass[] { cl.getEnumParameter(), cl.getChannelParameter(),
				cl.getIntegerParameter(), cl.getDoubleParameter(),
				cl.getCrvParameter(), cl.getEnumLiteral() };
	}

	/**
	 * This method builds the local scope of symbols by going up the EObject
	 * hierarchy recursively. Each scope gets its own symbol table, i.e. it
	 * supports overriding local variables and parameters in subsequent.
	 */
	private IScope defaultCStuff(final EObject ctx, IScope outerScope) {
		if (ctx.eContainer() == null) {
			return outerScope;
		}
		// call recursivly for the container
		outerScope = defaultCStuff(ctx.eContainer(), outerScope);

		if (ctx instanceof ForeachStatement)
		{
			outerScope = scopeForForeachStatement((ForeachStatement) ctx, outerScope);

		}
		else if (ctx instanceof FunctionDeclaration)
		{
			outerScope = scopeForFunctionDeclaration((FunctionDeclaration) ctx, outerScope);
		}
		else if (ctx instanceof Namespace)
		{
			outerScope = scopeForNamespace((Namespace) ctx, outerScope);
		}

		if (ctx.eContainer() instanceof StatementList)
		{
			final StatementList list = (StatementList) ctx.eContainer();
			outerScope = scopeForStatementList(list, list.getStatements().indexOf(ctx), outerScope);
		}
		return outerScope;
	}

	/**
	 * returns all the symbols defined within a namespace i.e. all the functions
	 * in its body
	 */
	private IScope scopeForNamespace(final Namespace ctx, final IScope outerScope) {
		final List<IEObjectDescription> list = new ArrayList<IEObjectDescription>();
		for (final SymbolDeclaration f : ctx.getFunctions()) {
			list.add(EObjectDescription.create(f.getName(), f));
		}
		return MapBasedScope.createScope(outerScope, list);
	}

	/**
	 * returns all symbols defined in a function declaration, specifically its
	 * parameters
	 */
	private IScope scopeForFunctionDeclaration(final FunctionDeclaration ctx, final IScope outerScope) {
		final List<IEObjectDescription> list = new ArrayList<IEObjectDescription>();
		for (final SymbolDeclaration arg : ctx.getArgs()) {
			list.add(EObjectDescription.create(arg.getName(), arg));
		}
		return MapBasedScope.createScope(outerScope, list);
	}

	/**
	 * returns the symbols defined within a For statements, i.e. its iterator
	 * variable declaration
	 */
	private IScope scopeForForeachStatement(final ForeachStatement ctx, final IScope outerScope) {
		final List<IEObjectDescription> list = new ArrayList<IEObjectDescription>();
		final SymbolDeclaration iterator = ctx.getIterator();
		list.add(EObjectDescription.create(iterator.getName(), iterator));
		return MapBasedScope.createScope(outerScope, list);
	}

	/**
	 * returns all the symbols defined in a statement list that are defined
	 * before the index. This is to make sure that you first define a variable
	 * before you use it.
	 */
	private IScope scopeForStatementList(final StatementList stmtList, final int contextIndex, final IScope outerScope) {
		final List<IEObjectDescription> list = new ArrayList<IEObjectDescription>();
		for (int i = 0; i < contextIndex; i++) {
			final Statement statement = stmtList.getStatements().get(i);
			if (statement instanceof LocalVariableDeclarationStatement) {
				final SymbolDeclaration var = ((LocalVariableDeclarationStatement) statement).getVar();
				list.add(EObjectDescription.create(var.getName(), var));
			}
		}
		return list.isEmpty() ? outerScope : MapBasedScope.createScope(outerScope, list);
	}

	/**
	 * Helper class to be used with FilteringScope that accepts only those
	 * elements that have the scope (hi, crc, pat, etc.) that is passed into the
	 * constructor. Take a look at the OD package of the common language to
	 * understand how the scopes are put into the IEObjectDescriptions.
	 */
	private final class ScopeFilterPredicate implements Predicate<IEObjectDescription>
	{
		private final String	scope;

		private ScopeFilterPredicate(final String scope)
		{
			this.scope = scope;
		}

		@Override
		public boolean apply(final IEObjectDescription input) {
			final String userData = input.getUserData(CommonResourceDescriptionStrategy.KEY_SCOPE);
			if (userData == null) return false;
			return userData.equals(scope);
		}
	}

}
