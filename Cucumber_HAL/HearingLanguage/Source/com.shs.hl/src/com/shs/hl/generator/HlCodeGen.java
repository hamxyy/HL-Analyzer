/*
 * generated by Xtext
 */
package com.shs.hl.generator;

import static com.google.common.collect.Iterables.addAll;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.generator.JavaIoFileSystemAccess;
import org.eclipse.xtext.mwe.ContainersStateFactory;
import org.eclipse.xtext.mwe.PathTraverser;
import org.eclipse.xtext.resource.IResourceServiceProvider;
import org.eclipse.xtext.resource.containers.DelegatingIAllContainerAdapter;
import org.eclipse.xtext.resource.containers.IAllContainersState;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;

import com.google.common.base.Predicate;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Provider;
import com.shs.hl.generator.GenerationInfo.PlatformInformation;

public class HlCodeGen
{

	private String					newLine					= System.getProperty("line.separator");

	// com.shs.hl.generator.HlCodeGen
	@Inject
	private Provider<ResourceSet>	resourceSetProvider;

	private final String			STDLIBTAG				= "com.shs.hl.stdlib";

	// @Inject
	private JavaIoFileSystemAccess	fileAccess;
	// @Inject
	private IHLGenerator			generator;
	// @Inject
	private IResourceValidator		validator;
	// @Inject
	// private IResourceServiceProvider resourceService;

	private String					modelPath				= "";
	private String					output					= "src-gen/";
	private PlatformInformation		plf						= PlatformInformation.UNKNOWN;

	private boolean					debug					= false;
	private ContainersStateFactory	containersStateFactory	= new ContainersStateFactory();

	
	
	
	public static void main(String[] args)
	{
		if (args.length == 0)
		{
			System.err.println("Aborting: no model or stdlib version specified!");
			usage();
			return;
		}
		Injector injector = new com.shs.hl.HearingLanguageStandaloneSetup().createInjectorAndDoEMFRegistration();
		HlCodeGen generator = injector.getInstance(HlCodeGen.class);
		
		generator.runGenerator(injector, args);

	}

	private static void usage()
	{
		System.out.println();
		System.out.println("------------------Hearing Language Code transformator --------------------------");
		System.out.println("usage:  HlCodeGen -model=<model path>   -platform=<some platform>   [-output=<someDestination>]");
		System.out.println("");
		System.out.println("   model:       Referenced model");
		System.out.println("");
		System.out.println("   platform:    Hardware platform to be referenced");
		System.out.println("                Valid values are D8 and D9");
		System.out.println("");
		System.out.println("optional:");
		System.out.println("");
		System.out.println("   output:      output directory [default src-gen under model]");
		System.out.println("                Specify always relative to model!");
	}

	
	// ============================================================================================
	// Main entry
	// ============================================================================================
	public void runGenerator(Injector inj, String[] args)
	{
		Init(inj, args);
		
		runGeneratorInternal();
	}

	
	// ============================================================================================
	// Initialization
	// ============================================================================================
	private boolean Init(Injector inj, String[] args)
	{
		if (inj == null) return false;

		generator = inj.getInstance(IHLGenerator.class);
		validator = inj.getInstance(IResourceValidator.class);
		fileAccess = inj.getInstance(JavaIoFileSystemAccess.class);
		// resourceService = inj.getInstance(IResourceServiceProvider.class);

		if (generator == null || validator == null || fileAccess == null)
		{
			System.out.println("Could not initaliz components - please check injector");
			return false;
		}

		boolean result = parseArguments(args);
		if (!result)
		{
			System.out.println("Invalid arguments");
		}
		return result;

	}
	
	

	private boolean parseArguments(String[] args)
	{
		boolean foundModel = false;
		boolean foundPlatform = false;

		if (args == null || args.length == 0) return false;
		for (String arg : args)
		{
			String tmpArg = arg.trim().toLowerCase();
			if (tmpArg.startsWith("-model"))
			{
				tmpArg = tmpArg.replace("-model=", "");
				modelPath = tmpArg;
				foundModel = true;
			}

			if (tmpArg.startsWith("-platform"))
			{
				tmpArg = tmpArg.replace("-platform=", "");

				plf = PlatformInformation.GetBestMatch(tmpArg, null);
				PrintOnDebug("Specified Platform: " + tmpArg + " ----->>>" + plf.toString());
				if (plf != PlatformInformation.UNKNOWN)
				{
					foundPlatform = true;
				}
			}

			if (tmpArg.startsWith("-output"))
			{
				tmpArg = tmpArg.replace("-output=","");
				output = tmpArg;
			}

			if (tmpArg.startsWith("-debug"))
			{
				debug = true;
			}
		}

		if (!foundModel)
		{
			System.err.println("No valid model is specified");
		}

		if (!foundPlatform)
		{
			System.err.println("No valid platform definition found");
		}
		return foundModel & foundPlatform;
	}
	
	// ============================================================================================
	// Main task
	// ============================================================================================
	private void runGeneratorInternal()
	{
		// ----------------------------------------------------------------------------------------
		// Classpath and Stdlibs
		// ----------------------------------------------------------------------------------------
		List<String> searchpath 	= prepareClassPath();
		List<String> foundStdlibs 	= filterStdlibs(searchpath, STDLIBTAG);

		if (!validateStdlibs(foundStdlibs, this.plf))
		{
			System.err.println("Invalid or no valid Stdlib found! - cannot generate any code");
			return;
		}

		// ----------------------------------------------------------------------------------------
		// Add defined model elements and stdlib elements
		// ----------------------------------------------------------------------------------------
		List<String> modelPath 		= preparePath(this.modelPath);
		Multimap<String, URI> uris 	= prepareModelPath(modelPath, foundStdlibs, this.plf);

		if (uris == null)
		{
			PrintOnDebug("ERROR: Cannot retrieve model information or stdlib - abort generation");
			return;
		}

		
		
		// ----------------------------------------------------------------------------------------
		// Prepare Resources for generator
		// ----------------------------------------------------------------------------------------
		ResourceSet set = prepareResource(modelPath, uris);

		// ----------------------------------------------------------------------------------------
		// Validate Resources
		// ----------------------------------------------------------------------------------------		
		List<Issue> list = this.validate(set);
		// List<Issue> list = validator.validate(set, CheckMode.ALL, CancelIndicator.NullImpl);
		
		
		if (!showInformation(uris,list ))
		{
			return;
		}


		// ----------------------------------------------------------------------------------------
		// configure and start the generator
		// ----------------------------------------------------------------------------------------
		generateCode(set, uris);
	}
	
	
	
	private boolean showInformation(Multimap<String, URI> uris ,List<Issue> issues)
	{
		boolean result = (issues==null||issues.isEmpty());
		String accessKey="";
		
		for (String str :uris.keySet())
		{
			if (str.contains(STDLIBTAG))
			{
				accessKey=str;
			}
		}
		
		String fileInfo = null;
		try
		{
			fileInfo = new File(".").getCanonicalPath();
		
		}
		catch (IOException e)
		{
			
		}
				
		System.out.println("--------------------------------------------------------------------------------");
		System.out.println("Defined paltform     : "+plf.toString());
		System.out.println("     found lib --->    " + accessKey);
		System.out.println("");
		System.out.println("Working directory    : "+fileInfo);
		System.out.println("Model location       : "+this.modelPath);
		System.out.println("Defined output       : "+output);
		System.out.println("");
		System.out.println("--------------------------------------------------------------------------------");
		System.out.println("");
			
		if (!result)
		{
			System.out.println("Model validation failed ("+issues.size()+" issues)");
			for(Issue err : issues)
			{
				System.err.println(err.toString());
			}
			System.err.flush();
		}
		
		System.out.flush();
		return result;	
	}
	// ============================================================================================
	// Helper functions
	// ============================================================================================
	private List<String> prepareClassPath()
	{
		List<String> tmplist = new ArrayList<String>();

		String classPath = System.getProperty("java.class.path");
		String separator = System.getProperty("path.separator");
		String[] strings = classPath.split(separator);

		StringBuilder builder = new StringBuilder();
		for (String path : strings)
		{
			if (debug)
			{
				builder.append(path).append(newLine);
			}
			tmplist.add(path);
		}

		if (debug)
		{
			String str = builder.toString();
			System.out.println("DEFINED CLASSPATH");
			System.out.println(str);
			System.out.println("END DEFINED CLASSPATH   <<<<<<<<<<<<");
			System.out.flush();
		}

		return tmplist;
	}

	private List<String> preparePath(String rootPath)
	{
		List<String> tmp = new ArrayList<String>();
		if (StringUtils.isNotBlank(rootPath))
		{
			if (new File(rootPath).exists())
			{
				tmp.add(rootPath);
			}
		}
		return tmp;
	}

	private static List<String> filterStdlibs(final List<String> elements, final String filterName)
	{
		final List<String> result = new ArrayList<String>();
		final Iterable<String> iterable = Iterables.filter(elements, new Predicate<String>()
		{
			@Override
			public boolean apply(final String input)
			{
				return input.contains(filterName);
			}
		});

		final Iterator<String> iterator = iterable.iterator();
		while (iterator.hasNext())
		{
			result.add(iterator.next());
		}
		return result;
	}

	private boolean validateStdlibs(List<String> libs, PlatformInformation platformInfo)
	{
		if (libs == null || libs.size() == 0)
		{
			System.out.println("no Libs");
			return false;
		}
		Multimap<PlatformInformation, String> mapping = HashMultimap.create();

		boolean found = false;
	
		PrintOnDebug("Searching for platform: " + platformInfo.toString());

		for (String lib : libs)
		{
			String version = getStdlibVersion(lib);

			PlatformInformation plf = PlatformInformation.GetBestMatch(version, null);

			if (debug)
			{
				System.out.println("Analyzing: " + lib + " ----->> " + version + "---> " + plf.toString());
			}
			mapping.put(plf, version);
			if (!found)
			{

				found = (plf == platformInfo);
				System.out.println("Valid platform? " + found);
			}
		}

		return found;
	}

	private Multimap<String, URI> prepareModelPath(List<String> modelPath, List<String> foundLibs, PlatformInformation platformInfo)
	{

		// Possible extension: Analyze Stdlibs and give feedback

		boolean added = false;
		for (String lib : foundLibs)
		{
			String version = getStdlibVersion(lib);
			PlatformInformation plf = PlatformInformation.GetBestMatch(version, null);

			if (plf == platformInfo)
			{
				if (!added)
				{
					modelPath.add(lib);
					added = true;
					break;
				}
			}
		}

		if (!added)
		{
			System.err.println("No valid stdlib found - abort");
			return null;
		}

		Multimap<String, URI> uris = new PathTraverser().resolvePathes(modelPath, new Predicate<URI>()
		{
			public boolean apply(URI input)
			{
				boolean result = true;
				// if (getUriFilter() != null)
				// result = getUriFilter().matches(input);
				if (result) result = IResourceServiceProvider.Registry.INSTANCE.getResourceServiceProvider(input) != null;
				return result;
			}
		});

		return uris;

	}

	private String getStdlibVersion(String str)
	{

		int firstPosition = str.indexOf(STDLIBTAG);

		String tmpString = str.substring(firstPosition);
		tmpString.replace(STDLIBTAG, "");
		if (tmpString.endsWith(".jar"))
		{
			tmpString = tmpString.substring(0, tmpString.lastIndexOf(".jar"));
		}
		if (tmpString.startsWith("."))
		{
			tmpString = tmpString.replaceFirst(".", "");

		}

		// in case of
		int firstPathSeperator = tmpString.indexOf("\\");
		if (firstPathSeperator > 0)
		{
			tmpString = tmpString.substring(0, firstPathSeperator);
		}

		// in case of versioned jars
		int firstSeperator = tmpString.indexOf("_");
		if (firstSeperator > 0)
		{
			tmpString = tmpString.substring(0, firstSeperator);
		}

		// now we should have a blank string representation of a stdlib
		// either contained in a jar or as a loaded resource
		return tmpString.replace(STDLIBTAG, "").replaceAll("^\\.", "");
	}

	private ResourceSet prepareResource(List<String> modelPaths, Multimap<String, URI> uris)
	{
		ResourceSet set = resourceSetProvider.get();

		IAllContainersState containerState = containersStateFactory.getContainersState(modelPaths, uris);
		set.eAdapters().add(new DelegatingIAllContainerAdapter(containerState));

		// Create Resources
		Collection<URI> values = Sets.newHashSet(uris.values());

		PrintOnDebug("CREATING RESOURCES --------------");
		StringBuilder resoureInfo = new StringBuilder();

		for (URI uri : values)
		{
			if (debug)
			{
				resoureInfo.append(uri.toString()).append(newLine);
			}
			set.createResource(uri);
		}

		if (debug)
		{
			System.out.println(resoureInfo.toString());
			System.out.println("END CREATING RESOURCES --------------");
			System.out.flush();
		}

		return set;
	}

	protected List<Issue> validate(ResourceSet resourceSet)
	{
		List<Issue> issues = Lists.newArrayList();
		List<Resource> resources = Lists.newArrayList(resourceSet.getResources());

		for (Resource resource : resources)
		{
			IResourceServiceProvider resourceServiceProvider = IResourceServiceProvider.Registry.INSTANCE.getResourceServiceProvider(resource
					.getURI());
			if (resourceServiceProvider != null)
			{
				IResourceValidator resourceValidator = resourceServiceProvider.getResourceValidator();
				List<Issue> result = resourceValidator.validate(resource, CheckMode.ALL, null);
				addAll(issues, result);
			}
		}
		return issues;
	}

	protected void generateCode(ResourceSet set, Multimap<String, URI> uris)
	{

		if (output == "")
		{
			output = "src-gen/";
		}
		fileAccess.setOutputPath(output);

		// iterate only over model files

		Collection<URI> modelLinks = uris.get(this.modelPath);
		String fileInfo = "";
		try
		{
			fileInfo = new File(".").getCanonicalPath();
		}
		catch (IOException e)
		{
			
		}
		System.out.println("----------------> " + fileInfo + " <----------------");
		System.out.println("Generator configured for "+plf.toString()+" --- "+plf.getShowingName());
		System.out.flush();
		generator.SetPlatformVersion(plf);
		
		for (URI link : modelLinks)
		{
			Resource res = set.getResource(link, true);

			System.out.print("Generate code for " + link.toFileString() + "--->");
			generator.doGenerate(res, fileAccess);
			System.out.println("done");
			System.out.flush();
		}

		// generator.doGenerate(resource, fileAccess);

		System.out.println("Code generation finished.");
	}



	private void PrintOnDebug(String string)
	{
		if (debug)
		{
			System.out.println(string);
		}
	}

}
